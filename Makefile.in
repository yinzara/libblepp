#Standard boilerplate
prefix = @prefix@
exec_prefix = @exec_prefix@
mandir = @mandir@
includedir = @includedir@
datarootdir = @datarootdir@
pkgconfig = @PKGCONFIG_LIBDIR@
srcdir = @srcdir@
libdir=@libdir@
LOADLIBES =

vpath %.cc $(srcdir)

ifneq "$(DESTDIR)" ""
DESTDIR+=/
endif

CXX=@CXX@
LD=@LD@
CXXFLAGS=@CXXFLAGS@ -I$(srcdir)
LDFLAGS=@LDFLAGS@

hdr = $(DESTDIR)$(includedir)/
lib = $(DESTDIR)$(libdir)/

archive=libble++.a
soname=libble++.so
soname1=libble++.so.0
soname2=libble++.so.0.5
set_soname=-Wl,-soname,libble++.so.0

# Core library objects (always compiled)
# lescan.o contains parse_advertisement_packet() which is transport-agnostic
LIBOBJS=src/att.o src/uuid.o src/bledevice.o src/att_pdu.o src/pretty_printers.o src/blestatemachine.o src/float.o src/logging.o src/lescan.o src/bleclienttransport.o

# Validate: require at least one transport
ifndef BLEPP_BLUEZ_SUPPORT
ifndef BLEPP_NIMBLE_SUPPORT
$(error At least one of BLEPP_BLUEZ_SUPPORT or BLEPP_NIMBLE_SUPPORT must be defined)
endif
endif

# BlueZ transport support (client + optional server)
ifdef BLEPP_BLUEZ_SUPPORT
LIBOBJS+=src/bluez_client_transport.o
CXXFLAGS+=-DBLEPP_BLUEZ_SUPPORT
LOADLIBES+=-lbluetooth
endif

# Nimble transport support (client + optional server)
ifdef BLEPP_NIMBLE_SUPPORT
LIBOBJS+=src/nimble_client_transport.o
CXXFLAGS+=-DBLEPP_NIMBLE_SUPPORT

# Find Nimble BLE stack (required for Nimble transport)
NIMBLE_ROOT ?= $(shell pwd)/../atbm-wifi/ble_host/nimble_v42

ifneq ($(wildcard $(NIMBLE_ROOT)),)
# Add Nimble include directories
CXXFLAGS+=-I$(NIMBLE_ROOT)/nimble/include \
    -I$(NIMBLE_ROOT)/nimble/host/include \
    -I$(NIMBLE_ROOT)/nimble/host/services/gap/include \
    -I$(NIMBLE_ROOT)/nimble/host/services/gatt/include \
    -I$(NIMBLE_ROOT)/nimble/host/util/include \
    -I$(NIMBLE_ROOT)/porting/nimble/include \
    -I$(NIMBLE_ROOT)/ext/tinycrypt/include
endif


# Find Nimble library (dynamic linking)
# Look for libnimble.so or libnimble.a in NIMBLE_ROOT/lib or NIMBLE_ROOT/build
ifeq ($(NIMBLE_LIBDIR),)
NIMBLE_LIB_PATH=$(firstword $(wildcard $(NIMBLE_ROOT)/lib/libnimble.so $(NIMBLE_ROOT)/build/libnimble.so $(NIMBLE_ROOT)/lib/libnimble.a $(NIMBLE_ROOT)/build/libnimble.a))
ifeq ($(NIMBLE_LIB_PATH),)
$(error Nimble library not found. Please build Nimble as a shared library first. \
Expected location: $(NIMBLE_ROOT)/lib/libnimble.so or $(NIMBLE_ROOT)/build/libnimble.so)
endif
NIMBLE_LIBDIR=$(dir $(NIMBLE_LIB_PATH))
endif
LDFLAGS+=-L$(NIMBLE_LIBDIR) -Wl,-rpath,$(NIMBLE_LIBDIR)
LOADLIBES+=-lnimble
endif

# Server support objects
ifdef BLEPP_SERVER_SUPPORT
LIBOBJS+=src/bleattributedb.o src/blegattserver.o
CXXFLAGS+=-DBLEPP_SERVER_SUPPORT

# BlueZ server transport (only if BlueZ support enabled)
ifdef BLEPP_BLUEZ_SUPPORT
LIBOBJS+=src/bluez_transport.o
endif

# Nimble server transport (only if Nimble support enabled)
ifdef BLEPP_NIMBLE_SUPPORT
LIBOBJS+=src/nimble_transport.o
endif

endif

# Core examples that work with any transport
PROGS=examples/lescan_transport

# BlueZ-specific examples (use HCIScanner and BLEGATTStateMachine::connect_blocking)
ifdef BLEPP_BLUEZ_SUPPORT
PROGS+=examples/lescan examples/blelogger examples/bluetooth examples/lescan_simple examples/temperature examples/read_device_name examples/write
endif

.PHONY: all clean testclean install lib progs test doc install-so install-a install-hdr install-pkgconfig

all: lib progs test doc

lib: $(soname) $(archive)
progs:$(PROGS)


distclean: clean
	rm -f Makefile config.log config.status libblepp.pc
clean: testclean
	rm -f $(PROGS) *.o */*.o *.so.* *.so *.d */*.d $(soname) $(soname1) $(soname2) $(archive)
testclean:
	rm -f tests/*.result tests/*.test tests/*.result_ tests/results



doc:


$(soname2): $(LIBOBJS)
	$(LD) -shared -o $(soname2) $(LIBOBJS) $(LDFLAGS) $(LOADLIBES)

$(soname1): $(soname2)
	rm -f $(soname1)
	ln -s $(soname2) $(soname1)

$(soname): $(soname1)
	rm -f $(soname)
	ln -s $(soname1) $(soname)

$(archive): $(LIBOBJS)
	ar crvs $(archive) $(LIBOBJS)
	ranlib $(archive)

$(PROGS):|$(soname)

$(PROGS:%=%.o): | examples
$(PROGS): % : %.o | examples
	$(LD) -o $@ $<  -L. -lble++

install: install-so install-a install-hdr install-pkgconfig


install-a: $(archive) | $(lib)
	cp $(archive) $(lib)

install-so: $(soname) $(soname1) $(soname2) | $(lib)
	cp $(soname) $(soname1) $(soname2) $(lib)

install-hdr: | $(hdr)
	cp -r $(srcdir)/blepp $(hdr)

install-pkgconfig:
	[ "$(pkgconfig)" = "" ] || mkdir -p $(DESTDIR)$(pkgconfig)
	[ "$(pkgconfig)" = "" ] || cp libblepp.pc $(DESTDIR)$(pkgconfig)/
	


docs:
	doxygen 


#Every .cc file in the tests directory is a test
# Transport-agnostic tests (work with any transport)
CORE_TESTS=test_transport test_scan

# BlueZ-specific tests (use HCIScanner hardware interface)
BLUEZ_TESTS=

# Combine tests based on what's enabled
TESTS=$(CORE_TESTS)
ifdef BLEPP_BLUEZ_SUPPORT
TESTS+=$(BLUEZ_TESTS)
endif

#Get the intermediate file names from the list of tests.
TEST_RESULT=$(TESTS:%=tests/%.result)


# Don't delete the intermediate files, since these can take a
# long time to regenerate
.PRECIOUS: tests/%.result_ tests/%.test

test:tests/results

#We don't want this file hanging around on failure since we
#want the build depend on it. If we leave it behing then typing make
#twice in a row will suceed, since make will find the file and not try
#to rebuild it.
.DELETE_ON_ERROR: tests/results

tests/results:$(TEST_RESULT)
	cat $(TEST_RESULT) > tests/results
	@echo -------------- Test Results ---------------
	@cat tests/results
	@echo -------------------------------------------
	@ ! grep -qv OK tests/results 


#Build a test executable from a test program. On compile error,
#create an executable which declares the error.
tests/%.test: tests/%.cc $(LIBOBJS) | tests
	$(CXX) $(CXXFLAGS) $^ -o $@ -I . $(LDFLAGS) $(LOADLIBES) || {  echo "echo 'Compile error!' ; return 126" > $@ ; chmod +x $@; }

#Run the program and either use it's output (it should just say OK)
#or a failure message
tests/%.result_: tests/%.test | tests
	$< > $@ 2>&1 ; \
	a=$$? ;\
	if [ $$a != 0 ]; \
	then \
	   if [ $$a -ge 128 ] ; \
	   then \
	       echo Crash!! > $@ ; \
	   elif [ $$a -ne 126 ] ;\
	   then \
	       echo Failed > $@ ; \
	   fi;\
	else\
	    echo OK >> $@;\
	fi
	
tests/%.result: tests/%.result_
	echo $*: `tail -1 $<` > $@

#Get the C style dependencies working. Note we need to massage the test dependencies
#to make the filenames correct
.deps:
	rm -f .deps .sourcefiles
	find . -name "*.cc" | xargs -IQQQ $(CXX) $(CXXFLAGS) -MM -MG QQQ | sed -e'/test/s!\(.*\)\.o:!tests/\1.test:!'  > .deps

#Make compilation generate dependencies
%.o %d: %.cc
	$(CXX) -o $@ -c $< $(CXXFLAGS) -MMD -MP -MF $*.d

include $(wildcard *.d */*.d)

$(LIBOBJS): | $(sort $(dir $(LIBOBJS)))
tests/results: | $(if $(wildcard tests),,tests)

examples tests $(sort $(dir $(LIBOBJS))) $(lib) $(hdr):
	mkdir -p $@


